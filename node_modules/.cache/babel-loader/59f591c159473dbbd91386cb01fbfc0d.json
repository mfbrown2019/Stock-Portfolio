{"ast":null,"code":"/* @flow */\n\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\nconst fs = require('fs');\n\nconst path = require('path');\n\nfunction log(message\n/*: string */\n) {\n  console.log(`[dotenv][DEBUG] ${message}`);\n} // Parses src into an Object\n\n\nfunction parse(src\n/*: string | Buffer */\n, options\n/*: ?DotenvParseOptions */\n)\n/*: DotenvParseOutput */\n{\n  const debug = Boolean(options && options.debug);\n  const obj = {}; // convert Buffers before splitting into lines and processing\n\n  src.toString().split('\\n').forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    const keyValueArr = line.match(/^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/); // matched?\n\n    if (keyValueArr != null) {\n      const key = keyValueArr[1]; // default undefined or missing values to empty string\n\n      let value = keyValueArr[2] || ''; // expand newlines in quoted values\n\n      const len = value ? value.length : 0;\n\n      if (len > 0 && value.charAt(0) === '\"' && value.charAt(len - 1) === '\"') {\n        value = value.replace(/\\\\n/gm, '\\n');\n      } // remove any surrounding quotes and extra spaces\n\n\n      value = value.replace(/(^['\"]|['\"]$)/g, '').trim();\n      obj[key] = value;\n    } else if (debug) {\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`);\n    }\n  });\n  return obj;\n} // Populates process.env from .env file\n\n\nfunction config(options\n/*: ?DotenvConfigOptions */\n)\n/*: DotenvConfigOutput */\n{\n  let dotenvPath = path.resolve(process.cwd(), '.env');\n  let encoding\n  /*: string */\n  = 'utf8';\n  let debug = false;\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = options.path;\n    }\n\n    if (options.encoding != null) {\n      encoding = options.encoding;\n    }\n\n    if (options.debug != null) {\n      debug = true;\n    }\n  }\n\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    const parsed = parse(fs.readFileSync(dotenvPath, {\n      encoding\n    }), {\n      debug\n    });\n    Object.keys(parsed).forEach(function (key) {\n      if (!process.env.hasOwnProperty(key)) {\n        process.env[key] = parsed[key];\n      } else if (debug) {\n        log(`\"${key}\" is already defined in \\`process.env\\` and will not be overwritten`);\n      }\n    });\n    return {\n      parsed\n    };\n  } catch (e) {\n    return {\n      error: e\n    };\n  }\n}\n\nmodule.exports.config = config;\nmodule.exports.load = config;\nmodule.exports.parse = parse;","map":{"version":3,"names":["fs","require","path","log","message","console","parse","src","options","debug","Boolean","obj","toString","split","forEach","line","idx","keyValueArr","match","key","value","len","length","charAt","replace","trim","config","dotenvPath","resolve","process","cwd","encoding","parsed","readFileSync","Object","keys","env","hasOwnProperty","e","error","module","exports","load"],"sources":["/Users/matthewbrown/Desktop/code/Summer/Stock-Portfolio/stock-portfolio/node_modules/@alpacahq/alpaca-trade-api/node_modules/dotenv/lib/main.js"],"sourcesContent":["/* @flow */\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\n\nconst fs = require('fs')\nconst path = require('path')\n\nfunction log (message /*: string */) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\n// Parses src into an Object\nfunction parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {\n  const debug = Boolean(options && options.debug)\n  const obj = {}\n\n  // convert Buffers before splitting into lines and processing\n  src.toString().split('\\n').forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    const keyValueArr = line.match(/^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/)\n    // matched?\n    if (keyValueArr != null) {\n      const key = keyValueArr[1]\n\n      // default undefined or missing values to empty string\n      let value = keyValueArr[2] || ''\n\n      // expand newlines in quoted values\n      const len = value ? value.length : 0\n      if (len > 0 && value.charAt(0) === '\"' && value.charAt(len - 1) === '\"') {\n        value = value.replace(/\\\\n/gm, '\\n')\n      }\n\n      // remove any surrounding quotes and extra spaces\n      value = value.replace(/(^['\"]|['\"]$)/g, '').trim()\n\n      obj[key] = value\n    } else if (debug) {\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`)\n    }\n  })\n\n  return obj\n}\n\n// Populates process.env from .env file\nfunction config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding /*: string */ = 'utf8'\n  let debug = false\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = options.path\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n    if (options.debug != null) {\n      debug = true\n    }\n  }\n\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug })\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!process.env.hasOwnProperty(key)) {\n        process.env[key] = parsed[key]\n      } else if (debug) {\n        log(`\"${key}\" is already defined in \\`process.env\\` and will not be overwritten`)\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    return { error: e }\n  }\n}\n\nmodule.exports.config = config\nmodule.exports.load = config\nmodule.exports.parse = parse\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}