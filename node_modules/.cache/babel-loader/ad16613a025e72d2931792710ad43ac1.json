{"ast":null,"code":"'use strict';\n\nconst bl = require('bl');\n\nconst IncompleteBufferError = require('./helpers.js').IncompleteBufferError;\n\nconst SIZES = {\n  0xc4: 2,\n  0xc5: 3,\n  0xc6: 5,\n  0xc7: 3,\n  0xc8: 4,\n  0xc9: 6,\n  0xca: 5,\n  0xcb: 9,\n  0xcc: 2,\n  0xcd: 3,\n  0xce: 5,\n  0xcf: 9,\n  0xd0: 2,\n  0xd1: 3,\n  0xd2: 5,\n  0xd3: 9,\n  0xd4: 3,\n  0xd5: 4,\n  0xd6: 6,\n  0xd7: 10,\n  0xd8: 18,\n  0xd9: 2,\n  0xda: 3,\n  0xdb: 5,\n  0xde: 3,\n  0xdc: 3,\n  0xdd: 5\n};\n\nfunction isValidDataSize(dataLength, bufLength, headerLength) {\n  return bufLength >= headerLength + dataLength;\n}\n\nmodule.exports = function buildDecode(decodingTypes, options) {\n  const context = {\n    decodingTypes,\n    options,\n    decode\n  };\n  return decode;\n\n  function decode(buf) {\n    // TODO: Make it into ensureBl handler ?\n    if (!(buf instanceof bl)) {\n      buf = bl().append(buf);\n    }\n\n    const result = tryDecode(buf, 0, context); // Handle worst case ASAP and keep code flat\n\n    if (!result) throw new IncompleteBufferError();\n    buf.consume(result[1]);\n    return result[0];\n  }\n};\n\nfunction decodeArray(buf, initialOffset, length, headerLength, context) {\n  let offset = initialOffset;\n  const result = [];\n  let i = 0;\n\n  while (i++ < length) {\n    const decodeResult = tryDecode(buf, offset, context);\n    if (!decodeResult) return null;\n    result.push(decodeResult[0]);\n    offset += decodeResult[1];\n  }\n\n  return [result, headerLength + offset - initialOffset];\n}\n\nfunction decodeMap(buf, offset, length, headerLength, context) {\n  const _temp = decodeArray(buf, offset, 2 * length, headerLength, context);\n\n  if (!_temp) return null;\n  const [result, consumedBytes] = _temp;\n  let isPlainObject = !context.options.preferMap;\n\n  if (isPlainObject) {\n    for (let i = 0; i < 2 * length; i += 2) {\n      if (typeof result[i] !== 'string') {\n        isPlainObject = false;\n        break;\n      }\n    }\n  }\n\n  if (isPlainObject) {\n    const object = {};\n\n    for (let i = 0; i < 2 * length; i += 2) {\n      const key = result[i];\n      const val = result[i + 1];\n\n      if (key === '__proto__') {\n        if (context.options.protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property');\n        }\n\n        if (context.options.protoAction === 'remove') {\n          continue;\n        }\n      }\n\n      object[key] = val;\n    }\n\n    return [object, consumedBytes];\n  } else {\n    const mapping = new Map();\n\n    for (let i = 0; i < 2 * length; i += 2) {\n      const key = result[i];\n      const val = result[i + 1];\n      mapping.set(key, val);\n    }\n\n    return [mapping, consumedBytes];\n  }\n}\n\nfunction tryDecode(buf, initialOffset, context) {\n  if (buf.length <= initialOffset) return null;\n  const bufLength = buf.length - initialOffset;\n  let offset = initialOffset;\n  const first = buf.readUInt8(offset);\n  offset += 1;\n  const size = SIZES[first] || -1;\n  if (bufLength < size) return null;\n  if (first < 0x80) return [first, 1]; // 7-bits positive ints\n\n  if ((first & 0xf0) === 0x80) {\n    const length = first & 0x0f;\n    const headerSize = offset - initialOffset; // we have a map with less than 15 elements\n\n    return decodeMap(buf, offset, length, headerSize, context);\n  }\n\n  if ((first & 0xf0) === 0x90) {\n    const length = first & 0x0f;\n    const headerSize = offset - initialOffset; // we have an array with less than 15 elements\n\n    return decodeArray(buf, offset, length, headerSize, context);\n  }\n\n  if ((first & 0xe0) === 0xa0) {\n    // fixstr up to 31 bytes\n    const length = first & 0x1f;\n    if (!isValidDataSize(length, bufLength, 1)) return null;\n    const result = buf.toString('utf8', offset, offset + length);\n    return [result, length + 1];\n  }\n\n  if (first >= 0xc0 && first <= 0xc3) return decodeConstants(first);\n\n  if (first >= 0xc4 && first <= 0xc6) {\n    const length = buf.readUIntBE(offset, size - 1);\n    offset += size - 1;\n    if (!isValidDataSize(length, bufLength, size)) return null;\n    const result = buf.slice(offset, offset + length);\n    return [result, size + length];\n  }\n\n  if (first >= 0xc7 && first <= 0xc9) {\n    const length = buf.readUIntBE(offset, size - 2);\n    offset += size - 2;\n    const type = buf.readInt8(offset);\n    offset += 1;\n    if (!isValidDataSize(length, bufLength, size)) return null;\n    return decodeExt(buf, offset, type, length, size, context);\n  }\n\n  if (first >= 0xca && first <= 0xcb) return decodeFloat(buf, offset, size - 1);\n  if (first >= 0xcc && first <= 0xcf) return decodeUnsignedInt(buf, offset, size - 1);\n  if (first >= 0xd0 && first <= 0xd3) return decodeSigned(buf, offset, size - 1);\n\n  if (first >= 0xd4 && first <= 0xd8) {\n    const type = buf.readInt8(offset); // Signed\n\n    offset += 1;\n    return decodeExt(buf, offset, type, size - 2, 2, context);\n  }\n\n  if (first >= 0xd9 && first <= 0xdb) {\n    const length = buf.readUIntBE(offset, size - 1);\n    offset += size - 1;\n    if (!isValidDataSize(length, bufLength, size)) return null;\n    const result = buf.toString('utf8', offset, offset + length);\n    return [result, size + length];\n  }\n\n  if (first >= 0xdc && first <= 0xdd) {\n    const length = buf.readUIntBE(offset, size - 1);\n    offset += size - 1;\n    return decodeArray(buf, offset, length, size, context);\n  }\n\n  if (first >= 0xde && first <= 0xdf) {\n    let length;\n\n    switch (first) {\n      case 0xde:\n        // maps up to 2^16 elements - 2 bytes\n        length = buf.readUInt16BE(offset);\n        offset += 2; // console.log(offset - initialOffset)\n\n        return decodeMap(buf, offset, length, 3, context);\n\n      case 0xdf:\n        length = buf.readUInt32BE(offset);\n        offset += 4;\n        return decodeMap(buf, offset, length, 5, context);\n    }\n  }\n\n  if (first >= 0xe0) return [first - 0x100, 1]; // 5 bits negative ints\n\n  throw new Error('not implemented yet');\n}\n\nfunction decodeSigned(buf, offset, size) {\n  let result;\n  if (size === 1) result = buf.readInt8(offset);\n  if (size === 2) result = buf.readInt16BE(offset);\n  if (size === 4) result = buf.readInt32BE(offset);\n  if (size === 8) result = readInt64BE(buf.slice(offset, offset + 8), 0);\n  return [result, size + 1];\n}\n\nfunction decodeExt(buf, offset, type, size, headerSize, context) {\n  const toDecode = buf.slice(offset, offset + size);\n  const decode = context.decodingTypes.get(type);\n  if (!decode) throw new Error('unable to find ext type ' + type);\n  const value = decode(toDecode);\n  return [value, headerSize + size];\n}\n\nfunction decodeUnsignedInt(buf, offset, size) {\n  const maxOffset = offset + size;\n  let result = 0;\n\n  while (offset < maxOffset) {\n    result += buf.readUInt8(offset++) * Math.pow(256, maxOffset - offset);\n  }\n\n  return [result, size + 1];\n}\n\nfunction decodeConstants(first) {\n  if (first === 0xc0) return [null, 1];\n  if (first === 0xc2) return [false, 1];\n  if (first === 0xc3) return [true, 1];\n}\n\nfunction decodeFloat(buf, offset, size) {\n  let result;\n  if (size === 4) result = buf.readFloatBE(offset);\n  if (size === 8) result = buf.readDoubleBE(offset);\n  return [result, size + 1];\n}\n\nfunction readInt64BE(buf, offset) {\n  var negate = (buf[offset] & 0x80) == 0x80; // eslint-disable-line\n\n  if (negate) {\n    let carry = 1;\n\n    for (let i = offset + 7; i >= offset; i--) {\n      const v = (buf[i] ^ 0xff) + carry;\n      buf[i] = v & 0xff;\n      carry = v >> 8;\n    }\n  }\n\n  const hi = buf.readUInt32BE(offset + 0);\n  const lo = buf.readUInt32BE(offset + 4);\n  return (hi * 4294967296 + lo) * (negate ? -1 : +1);\n}","map":{"version":3,"names":["bl","require","IncompleteBufferError","SIZES","isValidDataSize","dataLength","bufLength","headerLength","module","exports","buildDecode","decodingTypes","options","context","decode","buf","append","result","tryDecode","consume","decodeArray","initialOffset","length","offset","i","decodeResult","push","decodeMap","_temp","consumedBytes","isPlainObject","preferMap","object","key","val","protoAction","SyntaxError","mapping","Map","set","first","readUInt8","size","headerSize","toString","decodeConstants","readUIntBE","slice","type","readInt8","decodeExt","decodeFloat","decodeUnsignedInt","decodeSigned","readUInt16BE","readUInt32BE","Error","readInt16BE","readInt32BE","readInt64BE","toDecode","get","value","maxOffset","Math","pow","readFloatBE","readDoubleBE","negate","carry","v","hi","lo"],"sources":["/Users/matthewbrown/Desktop/code/Summer/Stock-Portfolio/stock-portfolio/node_modules/msgpack5/lib/decoder.js"],"sourcesContent":["'use strict'\n\nconst bl = require('bl')\nconst IncompleteBufferError = require('./helpers.js').IncompleteBufferError\n\nconst SIZES = {\n  0xc4: 2,\n  0xc5: 3,\n  0xc6: 5,\n  0xc7: 3,\n  0xc8: 4,\n  0xc9: 6,\n  0xca: 5,\n  0xcb: 9,\n  0xcc: 2,\n  0xcd: 3,\n  0xce: 5,\n  0xcf: 9,\n  0xd0: 2,\n  0xd1: 3,\n  0xd2: 5,\n  0xd3: 9,\n  0xd4: 3,\n  0xd5: 4,\n  0xd6: 6,\n  0xd7: 10,\n  0xd8: 18,\n  0xd9: 2,\n  0xda: 3,\n  0xdb: 5,\n  0xde: 3,\n  0xdc: 3,\n  0xdd: 5\n}\n\nfunction isValidDataSize (dataLength, bufLength, headerLength) {\n  return bufLength >= headerLength + dataLength\n}\n\nmodule.exports = function buildDecode (decodingTypes, options) {\n  const context = { decodingTypes, options, decode }\n  return decode\n\n  function decode (buf) {\n    // TODO: Make it into ensureBl handler ?\n    if (!(buf instanceof bl)) {\n      buf = bl().append(buf)\n    }\n\n    const result = tryDecode(buf, 0, context)\n    // Handle worst case ASAP and keep code flat\n    if (!result) throw new IncompleteBufferError()\n\n    buf.consume(result[1])\n    return result[0]\n  }\n}\n\nfunction decodeArray (buf, initialOffset, length, headerLength, context) {\n  let offset = initialOffset\n  const result = []\n  let i = 0\n\n  while (i++ < length) {\n    const decodeResult = tryDecode(buf, offset, context)\n    if (!decodeResult) return null\n\n    result.push(decodeResult[0])\n    offset += decodeResult[1]\n  }\n  return [result, headerLength + offset - initialOffset]\n}\n\nfunction decodeMap (buf, offset, length, headerLength, context) {\n  const _temp = decodeArray(buf, offset, 2 * length, headerLength, context)\n  if (!_temp) return null\n  const [result, consumedBytes] = _temp\n\n  let isPlainObject = !context.options.preferMap\n\n  if (isPlainObject) {\n    for (let i = 0; i < 2 * length; i += 2) {\n      if (typeof result[i] !== 'string') {\n        isPlainObject = false\n        break\n      }\n    }\n  }\n\n  if (isPlainObject) {\n    const object = {}\n    for (let i = 0; i < 2 * length; i += 2) {\n      const key = result[i]\n      const val = result[i + 1]\n\n      if (key === '__proto__') {\n        if (context.options.protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        if (context.options.protoAction === 'remove') {\n          continue\n        }\n      }\n\n      object[key] = val\n    }\n    return [object, consumedBytes]\n  } else {\n    const mapping = new Map()\n    for (let i = 0; i < 2 * length; i += 2) {\n      const key = result[i]\n      const val = result[i + 1]\n      mapping.set(key, val)\n    }\n    return [mapping, consumedBytes]\n  }\n}\n\nfunction tryDecode (buf, initialOffset, context) {\n  if (buf.length <= initialOffset) return null\n\n  const bufLength = buf.length - initialOffset\n  let offset = initialOffset\n\n  const first = buf.readUInt8(offset)\n  offset += 1\n\n  const size = SIZES[first] || -1\n  if (bufLength < size) return null\n\n  if (first < 0x80) return [first, 1] // 7-bits positive ints\n  if ((first & 0xf0) === 0x80) {\n    const length = first & 0x0f\n    const headerSize = offset - initialOffset\n    // we have a map with less than 15 elements\n    return decodeMap(buf, offset, length, headerSize, context)\n  }\n  if ((first & 0xf0) === 0x90) {\n    const length = first & 0x0f\n    const headerSize = offset - initialOffset\n    // we have an array with less than 15 elements\n    return decodeArray(buf, offset, length, headerSize, context)\n  }\n\n  if ((first & 0xe0) === 0xa0) {\n    // fixstr up to 31 bytes\n    const length = first & 0x1f\n    if (!isValidDataSize(length, bufLength, 1)) return null\n    const result = buf.toString('utf8', offset, offset + length)\n    return [result, length + 1]\n  }\n  if (first >= 0xc0 && first <= 0xc3) return decodeConstants(first)\n  if (first >= 0xc4 && first <= 0xc6) {\n    const length = buf.readUIntBE(offset, size - 1)\n    offset += size - 1\n\n    if (!isValidDataSize(length, bufLength, size)) return null\n    const result = buf.slice(offset, offset + length)\n    return [result, size + length]\n  }\n  if (first >= 0xc7 && first <= 0xc9) {\n    const length = buf.readUIntBE(offset, size - 2)\n    offset += size - 2\n\n    const type = buf.readInt8(offset)\n    offset += 1\n\n    if (!isValidDataSize(length, bufLength, size)) return null\n    return decodeExt(buf, offset, type, length, size, context)\n  }\n  if (first >= 0xca && first <= 0xcb) return decodeFloat(buf, offset, size - 1)\n  if (first >= 0xcc && first <= 0xcf) return decodeUnsignedInt(buf, offset, size - 1)\n  if (first >= 0xd0 && first <= 0xd3) return decodeSigned(buf, offset, size - 1)\n  if (first >= 0xd4 && first <= 0xd8) {\n    const type = buf.readInt8(offset) // Signed\n    offset += 1\n    return decodeExt(buf, offset, type, size - 2, 2, context)\n  }\n\n  if (first >= 0xd9 && first <= 0xdb) {\n    const length = buf.readUIntBE(offset, size - 1)\n    offset += size - 1\n\n    if (!isValidDataSize(length, bufLength, size)) return null\n    const result = buf.toString('utf8', offset, offset + length)\n    return [result, size + length]\n  }\n  if (first >= 0xdc && first <= 0xdd) {\n    const length = buf.readUIntBE(offset, size - 1)\n    offset += size - 1\n    return decodeArray(buf, offset, length, size, context)\n  }\n  if (first >= 0xde && first <= 0xdf) {\n    let length\n    switch (first) {\n      case 0xde:\n        // maps up to 2^16 elements - 2 bytes\n        length = buf.readUInt16BE(offset)\n        offset += 2\n        // console.log(offset - initialOffset)\n        return decodeMap(buf, offset, length, 3, context)\n\n      case 0xdf:\n        length = buf.readUInt32BE(offset)\n        offset += 4\n        return decodeMap(buf, offset, length, 5, context)\n    }\n  }\n  if (first >= 0xe0) return [first - 0x100, 1] // 5 bits negative ints\n\n  throw new Error('not implemented yet')\n}\n\nfunction decodeSigned (buf, offset, size) {\n  let result\n  if (size === 1) result = buf.readInt8(offset)\n  if (size === 2) result = buf.readInt16BE(offset)\n  if (size === 4) result = buf.readInt32BE(offset)\n  if (size === 8) result = readInt64BE(buf.slice(offset, offset + 8), 0)\n  return [result, size + 1]\n}\n\nfunction decodeExt (buf, offset, type, size, headerSize, context) {\n  const toDecode = buf.slice(offset, offset + size)\n\n  const decode = context.decodingTypes.get(type)\n  if (!decode) throw new Error('unable to find ext type ' + type)\n\n  const value = decode(toDecode)\n  return [value, headerSize + size]\n}\n\nfunction decodeUnsignedInt (buf, offset, size) {\n  const maxOffset = offset + size\n  let result = 0\n  while (offset < maxOffset) { result += buf.readUInt8(offset++) * Math.pow(256, maxOffset - offset) }\n  return [result, size + 1]\n}\n\nfunction decodeConstants (first) {\n  if (first === 0xc0) return [null, 1]\n  if (first === 0xc2) return [false, 1]\n  if (first === 0xc3) return [true, 1]\n}\n\nfunction decodeFloat (buf, offset, size) {\n  let result\n  if (size === 4) result = buf.readFloatBE(offset)\n  if (size === 8) result = buf.readDoubleBE(offset)\n  return [result, size + 1]\n}\n\nfunction readInt64BE (buf, offset) {\n  var negate = (buf[offset] & 0x80) == 0x80; // eslint-disable-line\n\n  if (negate) {\n    let carry = 1\n    for (let i = offset + 7; i >= offset; i--) {\n      const v = (buf[i] ^ 0xff) + carry\n      buf[i] = v & 0xff\n      carry = v >> 8\n    }\n  }\n\n  const hi = buf.readUInt32BE(offset + 0)\n  const lo = buf.readUInt32BE(offset + 4)\n  return (hi * 4294967296 + lo) * (negate ? -1 : +1)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}