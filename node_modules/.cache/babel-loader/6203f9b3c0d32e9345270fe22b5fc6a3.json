{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events = require(\"events\");\n\nconst WebSocket = require(\"ws\");\n\nconst entity = require(\"./entity\"); // Listeners\n// A client can listen on any of the following events, states, or errors\n// Connection states. Each of these will also emit EVENT.STATE_CHANGE\n\n\nvar STATE;\n\n(function (STATE) {\n  STATE.AUTHENTICATING = \"authenticating\";\n  STATE.CONNECTED = \"connected\";\n  STATE.CONNECTING = \"connecting\";\n  STATE.DISCONNECTED = \"disconnected\";\n  STATE.WAITING_TO_CONNECT = \"waiting to connect\";\n  STATE.WAITING_TO_RECONNECT = \"waiting to reconnect\";\n})(STATE = exports.STATE || (exports.STATE = {})); // Client events\n\n\nvar EVENT;\n\n(function (EVENT) {\n  EVENT.CLIENT_ERROR = \"client_error\";\n  EVENT.STATE_CHANGE = \"state_change\";\n  EVENT.AUTHORIZED = \"authorized\";\n  EVENT.UNAUTHORIZED = \"unauthorized\";\n  EVENT.ORDER_UPDATE = \"trade_updates\";\n  EVENT.ACCOUNT_UPDATE = \"account_updates\";\n  EVENT.STOCK_TRADES = \"stock_trades\";\n  EVENT.STOCK_QUOTES = \"stock_quotes\";\n  EVENT.STOCK_AGG_SEC = \"stock_agg_sec\";\n  EVENT.STOCK_AGG_MIN = \"stock_agg_min\";\n})(EVENT = exports.EVENT || (exports.EVENT = {})); // Connection errors Each of these will also emit EVENT.ERROR\n\n\nvar ERROR;\n\n(function (ERROR) {\n  ERROR.BAD_KEY_OR_SECRET = \"bad key id or secret\";\n  ERROR.CONNECTION_REFUSED = \"connection refused\";\n  ERROR.MISSING_API_KEY = \"missing api key\";\n  ERROR.MISSING_SECRET_KEY = \"missing secret key\";\n  ERROR.UNKNOWN = \"unknown error\";\n})(ERROR = exports.ERROR || (exports.ERROR = {}));\n/**\n * AlpacaStreamClient manages a connection to Alpaca's websocket api\n */\n\n\nclass AlpacaStreamClient extends events.EventEmitter {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.defaultOptions = {\n      // A list of subscriptions to subscribe to on connection\n      subscriptions: [],\n      // Whether the library should reconnect automatically\n      reconnect: true,\n      // Reconnection backoff: if true, then the reconnection time will be initially\n      // reconnectTimeout, then will double with each unsuccessful connection attempt.\n      // It will not exceed maxReconnectTimeout\n      backoff: true,\n      // Initial reconnect timeout (seconds) a minimum of 1 will be used if backoff=false\n      reconnectTimeout: 0,\n      // The maximum amount of time between reconnect tries (applies to backoff)\n      maxReconnectTimeout: 30,\n      // The amount of time to increment the delay between each reconnect attempt\n      backoffIncrement: 0.5,\n      // If true, client outputs detailed log messages\n      verbose: false,\n      // If true we will use the polygon ws data source, otherwise we use\n      // alpaca ws data source\n      usePolygon: false\n    }; // Set minimum reconnectTimeout of 1s if backoff=false\n\n    if (!opts.backoff && opts.reconnectTimeout < 1) {\n      opts.reconnectTimeout = 1;\n    } // Merge supplied options with defaults\n\n\n    this.session = Object.assign(this.defaultOptions, opts);\n    this.session.url = this.session.url.replace(/^http/, \"ws\") + \"/stream\";\n\n    if (this.session.apiKey.length === 0 && this.session.oauth.length === 0) {\n      throw new Error(ERROR.MISSING_API_KEY);\n    }\n\n    if (this.session.secretKey.length === 0 && this.session.oauth.length === 0) {\n      throw new Error(ERROR.MISSING_SECRET_KEY);\n    } // Keep track of subscriptions in case we need to reconnect after the client\n    // has called subscribe()\n\n\n    this.subscriptionState = {};\n    this.session.subscriptions.forEach(x => {\n      this.subscriptionState[x] = true;\n    });\n    this.currentState = STATE.WAITING_TO_CONNECT; // Register internal event handlers\n    // Log and emit every state change\n\n    Object.keys(STATE).forEach(s => {\n      this.on(STATE[s], () => {\n        this.currentState = STATE[s];\n        this.log(\"info\", `state change: ${STATE[s]}`);\n        this.emit(EVENT.STATE_CHANGE, STATE[s]);\n      });\n    }); // Log and emit every error\n\n    Object.keys(ERROR).forEach(e => {\n      this.on(ERROR[e], () => {\n        this.log(\"error\", ERROR[e]);\n        this.emit(EVENT.CLIENT_ERROR, ERROR[e]);\n      });\n    });\n  }\n\n  connect() {\n    // Reset reconnectDisabled since the user called connect() again\n    this.reconnectDisabled = false;\n    this.emit(STATE.CONNECTING);\n    this.conn = new WebSocket(this.session.url);\n    this.conn.once(\"open\", () => {\n      this.authenticate();\n    });\n    this.conn.on(\"message\", data => this.handleMessage(data));\n    this.conn.once(\"error\", err => {\n      this.emit(ERROR.CONNECTION_REFUSED);\n    });\n    this.conn.once(\"close\", () => {\n      this.emit(STATE.DISCONNECTED);\n\n      if (this.session.reconnect && !this.reconnectDisabled) {\n        this.reconnect();\n      }\n    });\n  }\n\n  _ensure_polygon(channels) {\n    if (this.polygon.connectCalled) {\n      if (channels) {\n        this.polygon.subscribe(channels);\n      }\n\n      return;\n    }\n\n    this.polygon.connect(channels);\n  }\n\n  _unsubscribe_polygon(channels) {\n    if (this.polygon.connectCalled) {\n      if (channels) {\n        this.polygon.unsubscribe(channels);\n      }\n    }\n  }\n\n  subscribe(keys) {\n    let wsChannels = [];\n    let polygonChannels = [];\n    keys.forEach(key => {\n      const poly = [\"Q.\", \"T.\", \"A.\", \"AM.\"];\n      let found = poly.filter(channel => key.startsWith(channel));\n\n      if (found.length > 0) {\n        polygonChannels.push(key);\n      } else {\n        wsChannels.push(key);\n      }\n    });\n\n    if (wsChannels.length > 0) {\n      const subMsg = {\n        action: \"listen\",\n        data: {\n          streams: wsChannels\n        }\n      };\n      this.send(JSON.stringify(subMsg));\n    }\n\n    if (polygonChannels.length > 0) {\n      this._ensure_polygon(polygonChannels);\n    }\n\n    keys.forEach(x => {\n      this.subscriptionState[x] = true;\n    });\n  }\n\n  unsubscribe(keys) {\n    // Currently, only Polygon channels can be unsubscribed from\n    let polygonChannels = [];\n    keys.forEach(key => {\n      const poly = [\"Q.\", \"T.\", \"A.\", \"AM.\"];\n      let found = poly.filter(channel => key.startsWith(channel));\n\n      if (found.length > 0) {\n        polygonChannels.push(key);\n      }\n    });\n\n    if (polygonChannels.length > 0) {\n      this._unsubscribe_polygon(polygonChannels);\n    }\n\n    keys.forEach(x => {\n      this.subscriptionState[x] = false;\n    });\n  }\n\n  subscriptions() {\n    // if the user unsubscribes from certain equities, they will still be\n    // under this.subscriptionState but with value \"false\", so we need to\n    // filter them out\n    return Object.keys(this.subscriptionState).filter(x => this.subscriptionState[x]);\n  }\n\n  onConnect(fn) {\n    this.on(STATE.CONNECTED, () => fn());\n  }\n\n  onDisconnect(fn) {\n    this.on(STATE.DISCONNECTED, () => fn());\n  }\n\n  onStateChange(fn) {\n    this.on(EVENT.STATE_CHANGE, newState => fn(newState));\n  }\n\n  onError(fn) {\n    this.on(EVENT.CLIENT_ERROR, err => fn(err));\n  }\n\n  onOrderUpdate(fn) {\n    this.on(EVENT.ORDER_UPDATE, orderUpdate => fn(orderUpdate));\n  }\n\n  onAccountUpdate(fn) {\n    this.on(EVENT.ACCOUNT_UPDATE, accountUpdate => fn(accountUpdate));\n  }\n\n  onPolygonConnect(fn) {\n    this.polygon.on(STATE.CONNECTED, () => fn());\n  }\n\n  onPolygonDisconnect(fn) {\n    this.polygon.on(STATE.DISCONNECTED, () => fn());\n  }\n\n  onStockTrades(fn) {\n    if (this.session.usePolygon) {\n      this.polygon.on(EVENT.STOCK_TRADES, function (subject, data) {\n        fn(subject, data);\n      });\n    } else {\n      this.on(EVENT.STOCK_TRADES, function (subject, data) {\n        fn(subject, data);\n      });\n    }\n  }\n\n  onStockQuotes(fn) {\n    if (this.session.usePolygon) {\n      this.polygon.on(EVENT.STOCK_QUOTES, function (subject, data) {\n        fn(subject, data);\n      });\n    } else {\n      this.on(EVENT.STOCK_QUOTES, function (subject, data) {\n        fn(subject, data);\n      });\n    }\n  }\n\n  onStockAggSec(fn) {\n    this.polygon.on(EVENT.STOCK_AGG_SEC, function (subject, data) {\n      fn(subject, data);\n    });\n  }\n\n  onStockAggMin(fn) {\n    if (this.session.usePolygon) {\n      this.polygon.on(EVENT.STOCK_AGG_MIN, function (subject, data) {\n        fn(subject, data);\n      });\n    } else {\n      this.on(EVENT.STOCK_AGG_MIN, function (subject, data) {\n        fn(subject, data);\n      });\n    }\n  }\n\n  send(data) {\n    this.conn.send(data);\n  }\n\n  disconnect() {\n    this.reconnectDisabled = true;\n    this.conn.close();\n\n    if (this.polygon) {\n      this.polygon.close();\n    }\n  }\n\n  state() {\n    return this.currentState;\n  }\n\n  get(key) {\n    return this.session[key];\n  }\n\n  reconnect() {\n    setTimeout(() => {\n      if (this.session.backoff) {\n        this.session.reconnectTimeout += this.session.backoffIncrement;\n\n        if (this.session.reconnectTimeout > this.session.maxReconnectTimeout) {\n          this.session.reconnectTimeout = this.session.maxReconnectTimeout;\n        }\n      }\n\n      this.connect();\n    }, this.session.reconnectTimeout * 1000);\n    this.emit(STATE.WAITING_TO_RECONNECT, this.session.reconnectTimeout);\n  }\n\n  authenticate() {\n    this.emit(STATE.AUTHENTICATING);\n    const authMsg = {\n      action: \"authenticate\",\n      data: {\n        key_id: this.session.apiKey,\n        secret_key: this.session.secretKey\n      }\n    };\n    this.send(JSON.stringify(authMsg));\n  }\n\n  handleMessage(data) {\n    // Heartbeat\n    const bytes = new Uint8Array(data);\n\n    if (bytes.length === 1 && bytes[0] === 1) {\n      return;\n    }\n\n    let message = JSON.parse(data);\n    const subject = message.stream;\n\n    if (\"error\" in message.data) {\n      console.log(message.data.error);\n    }\n\n    switch (subject) {\n      case \"authorization\":\n        this.authResultHandler(message.data.status);\n        break;\n\n      case \"listening\":\n        this.log(`listening to the streams: ${message.data.streams}`);\n        break;\n\n      case \"trade_updates\":\n        this.emit(EVENT.ORDER_UPDATE, message.data);\n        break;\n\n      case \"account_updates\":\n        this.emit(EVENT.ACCOUNT_UPDATE, message.data);\n        break;\n\n      default:\n        if (message.stream.startsWith(\"T.\")) {\n          this.emit(EVENT.STOCK_TRADES, subject, entity.AlpacaTrade(message.data));\n        } else if (message.stream.startsWith(\"Q.\")) {\n          this.emit(EVENT.STOCK_QUOTES, subject, entity.AlpacaQuote(message.data));\n        } else if (message.stream.startsWith(\"AM.\")) {\n          this.emit(EVENT.STOCK_AGG_MIN, subject, entity.AggMinuteBar(message.data));\n        } else {\n          this.emit(ERROR.PROTOBUF);\n        }\n\n    }\n  }\n\n  authResultHandler(authResult) {\n    switch (authResult) {\n      case \"authorized\":\n        this.emit(STATE.CONNECTED);\n        break;\n\n      case \"unauthorized\":\n        this.emit(ERROR.BAD_KEY_OR_SECRET);\n        this.disconnect();\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  log(level) {\n    if (this.session.verbose) {\n      for (var _len = arguments.length, msg = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        msg[_key - 1] = arguments[_key];\n      }\n\n      console[level](...msg);\n    }\n  }\n\n}\n\nexports.AlpacaStreamClient = AlpacaStreamClient;","map":{"version":3,"names":["Object","defineProperty","exports","value","events","require","WebSocket","entity","STATE","AUTHENTICATING","CONNECTED","CONNECTING","DISCONNECTED","WAITING_TO_CONNECT","WAITING_TO_RECONNECT","EVENT","CLIENT_ERROR","STATE_CHANGE","AUTHORIZED","UNAUTHORIZED","ORDER_UPDATE","ACCOUNT_UPDATE","STOCK_TRADES","STOCK_QUOTES","STOCK_AGG_SEC","STOCK_AGG_MIN","ERROR","BAD_KEY_OR_SECRET","CONNECTION_REFUSED","MISSING_API_KEY","MISSING_SECRET_KEY","UNKNOWN","AlpacaStreamClient","EventEmitter","constructor","opts","defaultOptions","subscriptions","reconnect","backoff","reconnectTimeout","maxReconnectTimeout","backoffIncrement","verbose","usePolygon","session","assign","url","replace","apiKey","length","oauth","Error","secretKey","subscriptionState","forEach","x","currentState","keys","s","on","log","emit","e","connect","reconnectDisabled","conn","once","authenticate","data","handleMessage","err","_ensure_polygon","channels","polygon","connectCalled","subscribe","_unsubscribe_polygon","unsubscribe","wsChannels","polygonChannels","key","poly","found","filter","channel","startsWith","push","subMsg","action","streams","send","JSON","stringify","onConnect","fn","onDisconnect","onStateChange","newState","onError","onOrderUpdate","orderUpdate","onAccountUpdate","accountUpdate","onPolygonConnect","onPolygonDisconnect","onStockTrades","subject","onStockQuotes","onStockAggSec","onStockAggMin","disconnect","close","state","get","setTimeout","authMsg","key_id","secret_key","bytes","Uint8Array","message","parse","stream","console","error","authResultHandler","status","AlpacaTrade","AlpacaQuote","AggMinuteBar","PROTOBUF","authResult","level","msg"],"sources":["/Users/matthewbrown/Desktop/code/Summer/Stock-Portfolio/stock-portfolio/node_modules/@alpacahq/alpaca-trade-api/dist/resources/websockets.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events = require(\"events\");\nconst WebSocket = require(\"ws\");\nconst entity = require(\"./entity\");\n// Listeners\n// A client can listen on any of the following events, states, or errors\n// Connection states. Each of these will also emit EVENT.STATE_CHANGE\nvar STATE;\n(function (STATE) {\n    STATE.AUTHENTICATING = \"authenticating\";\n    STATE.CONNECTED = \"connected\";\n    STATE.CONNECTING = \"connecting\";\n    STATE.DISCONNECTED = \"disconnected\";\n    STATE.WAITING_TO_CONNECT = \"waiting to connect\";\n    STATE.WAITING_TO_RECONNECT = \"waiting to reconnect\";\n})((STATE = exports.STATE || (exports.STATE = {})));\n// Client events\nvar EVENT;\n(function (EVENT) {\n    EVENT.CLIENT_ERROR = \"client_error\";\n    EVENT.STATE_CHANGE = \"state_change\";\n    EVENT.AUTHORIZED = \"authorized\";\n    EVENT.UNAUTHORIZED = \"unauthorized\";\n    EVENT.ORDER_UPDATE = \"trade_updates\";\n    EVENT.ACCOUNT_UPDATE = \"account_updates\";\n    EVENT.STOCK_TRADES = \"stock_trades\";\n    EVENT.STOCK_QUOTES = \"stock_quotes\";\n    EVENT.STOCK_AGG_SEC = \"stock_agg_sec\";\n    EVENT.STOCK_AGG_MIN = \"stock_agg_min\";\n})((EVENT = exports.EVENT || (exports.EVENT = {})));\n// Connection errors Each of these will also emit EVENT.ERROR\nvar ERROR;\n(function (ERROR) {\n    ERROR.BAD_KEY_OR_SECRET = \"bad key id or secret\";\n    ERROR.CONNECTION_REFUSED = \"connection refused\";\n    ERROR.MISSING_API_KEY = \"missing api key\";\n    ERROR.MISSING_SECRET_KEY = \"missing secret key\";\n    ERROR.UNKNOWN = \"unknown error\";\n})((ERROR = exports.ERROR || (exports.ERROR = {})));\n/**\n * AlpacaStreamClient manages a connection to Alpaca's websocket api\n */\nclass AlpacaStreamClient extends events.EventEmitter {\n    constructor(opts = {}) {\n        super();\n        this.defaultOptions = {\n            // A list of subscriptions to subscribe to on connection\n            subscriptions: [],\n            // Whether the library should reconnect automatically\n            reconnect: true,\n            // Reconnection backoff: if true, then the reconnection time will be initially\n            // reconnectTimeout, then will double with each unsuccessful connection attempt.\n            // It will not exceed maxReconnectTimeout\n            backoff: true,\n            // Initial reconnect timeout (seconds) a minimum of 1 will be used if backoff=false\n            reconnectTimeout: 0,\n            // The maximum amount of time between reconnect tries (applies to backoff)\n            maxReconnectTimeout: 30,\n            // The amount of time to increment the delay between each reconnect attempt\n            backoffIncrement: 0.5,\n            // If true, client outputs detailed log messages\n            verbose: false,\n            // If true we will use the polygon ws data source, otherwise we use\n            // alpaca ws data source\n            usePolygon: false,\n        };\n        // Set minimum reconnectTimeout of 1s if backoff=false\n        if (!opts.backoff && opts.reconnectTimeout < 1) {\n            opts.reconnectTimeout = 1;\n        }\n        // Merge supplied options with defaults\n        this.session = Object.assign(this.defaultOptions, opts);\n        this.session.url = this.session.url.replace(/^http/, \"ws\") + \"/stream\";\n        if (this.session.apiKey.length === 0 && this.session.oauth.length === 0) {\n            throw new Error(ERROR.MISSING_API_KEY);\n        }\n        if (this.session.secretKey.length === 0 &&\n            this.session.oauth.length === 0) {\n            throw new Error(ERROR.MISSING_SECRET_KEY);\n        }\n        // Keep track of subscriptions in case we need to reconnect after the client\n        // has called subscribe()\n        this.subscriptionState = {};\n        this.session.subscriptions.forEach((x) => {\n            this.subscriptionState[x] = true;\n        });\n        this.currentState = STATE.WAITING_TO_CONNECT;\n        // Register internal event handlers\n        // Log and emit every state change\n        Object.keys(STATE).forEach((s) => {\n            this.on(STATE[s], () => {\n                this.currentState = STATE[s];\n                this.log(\"info\", `state change: ${STATE[s]}`);\n                this.emit(EVENT.STATE_CHANGE, STATE[s]);\n            });\n        });\n        // Log and emit every error\n        Object.keys(ERROR).forEach((e) => {\n            this.on(ERROR[e], () => {\n                this.log(\"error\", ERROR[e]);\n                this.emit(EVENT.CLIENT_ERROR, ERROR[e]);\n            });\n        });\n    }\n    connect() {\n        // Reset reconnectDisabled since the user called connect() again\n        this.reconnectDisabled = false;\n        this.emit(STATE.CONNECTING);\n        this.conn = new WebSocket(this.session.url);\n        this.conn.once(\"open\", () => {\n            this.authenticate();\n        });\n        this.conn.on(\"message\", (data) => this.handleMessage(data));\n        this.conn.once(\"error\", (err) => {\n            this.emit(ERROR.CONNECTION_REFUSED);\n        });\n        this.conn.once(\"close\", () => {\n            this.emit(STATE.DISCONNECTED);\n            if (this.session.reconnect && !this.reconnectDisabled) {\n                this.reconnect();\n            }\n        });\n    }\n    _ensure_polygon(channels) {\n        if (this.polygon.connectCalled) {\n            if (channels) {\n                this.polygon.subscribe(channels);\n            }\n            return;\n        }\n        this.polygon.connect(channels);\n    }\n    _unsubscribe_polygon(channels) {\n        if (this.polygon.connectCalled) {\n            if (channels) {\n                this.polygon.unsubscribe(channels);\n            }\n        }\n    }\n    subscribe(keys) {\n        let wsChannels = [];\n        let polygonChannels = [];\n        keys.forEach((key) => {\n            const poly = [\"Q.\", \"T.\", \"A.\", \"AM.\"];\n            let found = poly.filter((channel) => key.startsWith(channel));\n            if (found.length > 0) {\n                polygonChannels.push(key);\n            }\n            else {\n                wsChannels.push(key);\n            }\n        });\n        if (wsChannels.length > 0) {\n            const subMsg = {\n                action: \"listen\",\n                data: {\n                    streams: wsChannels,\n                },\n            };\n            this.send(JSON.stringify(subMsg));\n        }\n        if (polygonChannels.length > 0) {\n            this._ensure_polygon(polygonChannels);\n        }\n        keys.forEach((x) => {\n            this.subscriptionState[x] = true;\n        });\n    }\n    unsubscribe(keys) {\n        // Currently, only Polygon channels can be unsubscribed from\n        let polygonChannels = [];\n        keys.forEach((key) => {\n            const poly = [\"Q.\", \"T.\", \"A.\", \"AM.\"];\n            let found = poly.filter((channel) => key.startsWith(channel));\n            if (found.length > 0) {\n                polygonChannels.push(key);\n            }\n        });\n        if (polygonChannels.length > 0) {\n            this._unsubscribe_polygon(polygonChannels);\n        }\n        keys.forEach((x) => {\n            this.subscriptionState[x] = false;\n        });\n    }\n    subscriptions() {\n        // if the user unsubscribes from certain equities, they will still be\n        // under this.subscriptionState but with value \"false\", so we need to\n        // filter them out\n        return Object.keys(this.subscriptionState).filter((x) => this.subscriptionState[x]);\n    }\n    onConnect(fn) {\n        this.on(STATE.CONNECTED, () => fn());\n    }\n    onDisconnect(fn) {\n        this.on(STATE.DISCONNECTED, () => fn());\n    }\n    onStateChange(fn) {\n        this.on(EVENT.STATE_CHANGE, (newState) => fn(newState));\n    }\n    onError(fn) {\n        this.on(EVENT.CLIENT_ERROR, (err) => fn(err));\n    }\n    onOrderUpdate(fn) {\n        this.on(EVENT.ORDER_UPDATE, (orderUpdate) => fn(orderUpdate));\n    }\n    onAccountUpdate(fn) {\n        this.on(EVENT.ACCOUNT_UPDATE, (accountUpdate) => fn(accountUpdate));\n    }\n    onPolygonConnect(fn) {\n        this.polygon.on(STATE.CONNECTED, () => fn());\n    }\n    onPolygonDisconnect(fn) {\n        this.polygon.on(STATE.DISCONNECTED, () => fn());\n    }\n    onStockTrades(fn) {\n        if (this.session.usePolygon) {\n            this.polygon.on(EVENT.STOCK_TRADES, function (subject, data) {\n                fn(subject, data);\n            });\n        }\n        else {\n            this.on(EVENT.STOCK_TRADES, function (subject, data) {\n                fn(subject, data);\n            });\n        }\n    }\n    onStockQuotes(fn) {\n        if (this.session.usePolygon) {\n            this.polygon.on(EVENT.STOCK_QUOTES, function (subject, data) {\n                fn(subject, data);\n            });\n        }\n        else {\n            this.on(EVENT.STOCK_QUOTES, function (subject, data) {\n                fn(subject, data);\n            });\n        }\n    }\n    onStockAggSec(fn) {\n        this.polygon.on(EVENT.STOCK_AGG_SEC, function (subject, data) {\n            fn(subject, data);\n        });\n    }\n    onStockAggMin(fn) {\n        if (this.session.usePolygon) {\n            this.polygon.on(EVENT.STOCK_AGG_MIN, function (subject, data) {\n                fn(subject, data);\n            });\n        }\n        else {\n            this.on(EVENT.STOCK_AGG_MIN, function (subject, data) {\n                fn(subject, data);\n            });\n        }\n    }\n    send(data) {\n        this.conn.send(data);\n    }\n    disconnect() {\n        this.reconnectDisabled = true;\n        this.conn.close();\n        if (this.polygon) {\n            this.polygon.close();\n        }\n    }\n    state() {\n        return this.currentState;\n    }\n    get(key) {\n        return this.session[key];\n    }\n    reconnect() {\n        setTimeout(() => {\n            if (this.session.backoff) {\n                this.session.reconnectTimeout += this.session.backoffIncrement;\n                if (this.session.reconnectTimeout > this.session.maxReconnectTimeout) {\n                    this.session.reconnectTimeout = this.session.maxReconnectTimeout;\n                }\n            }\n            this.connect();\n        }, this.session.reconnectTimeout * 1000);\n        this.emit(STATE.WAITING_TO_RECONNECT, this.session.reconnectTimeout);\n    }\n    authenticate() {\n        this.emit(STATE.AUTHENTICATING);\n        const authMsg = {\n            action: \"authenticate\",\n            data: {\n                key_id: this.session.apiKey,\n                secret_key: this.session.secretKey,\n            },\n        };\n        this.send(JSON.stringify(authMsg));\n    }\n    handleMessage(data) {\n        // Heartbeat\n        const bytes = new Uint8Array(data);\n        if (bytes.length === 1 && bytes[0] === 1) {\n            return;\n        }\n        let message = JSON.parse(data);\n        const subject = message.stream;\n        if (\"error\" in message.data) {\n            console.log(message.data.error);\n        }\n        switch (subject) {\n            case \"authorization\":\n                this.authResultHandler(message.data.status);\n                break;\n            case \"listening\":\n                this.log(`listening to the streams: ${message.data.streams}`);\n                break;\n            case \"trade_updates\":\n                this.emit(EVENT.ORDER_UPDATE, message.data);\n                break;\n            case \"account_updates\":\n                this.emit(EVENT.ACCOUNT_UPDATE, message.data);\n                break;\n            default:\n                if (message.stream.startsWith(\"T.\")) {\n                    this.emit(EVENT.STOCK_TRADES, subject, entity.AlpacaTrade(message.data));\n                }\n                else if (message.stream.startsWith(\"Q.\")) {\n                    this.emit(EVENT.STOCK_QUOTES, subject, entity.AlpacaQuote(message.data));\n                }\n                else if (message.stream.startsWith(\"AM.\")) {\n                    this.emit(EVENT.STOCK_AGG_MIN, subject, entity.AggMinuteBar(message.data));\n                }\n                else {\n                    this.emit(ERROR.PROTOBUF);\n                }\n        }\n    }\n    authResultHandler(authResult) {\n        switch (authResult) {\n            case \"authorized\":\n                this.emit(STATE.CONNECTED);\n                break;\n            case \"unauthorized\":\n                this.emit(ERROR.BAD_KEY_OR_SECRET);\n                this.disconnect();\n                break;\n            default:\n                break;\n        }\n    }\n    log(level, ...msg) {\n        if (this.session.verbose) {\n            console[level](...msg);\n        }\n    }\n}\nexports.AlpacaStreamClient = AlpacaStreamClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}