{"ast":null,"code":"const type = -1;\n\nfunction encode(dt) {\n  if (dt === null) {\n    return;\n  }\n\n  const millis = dt * 1;\n  const seconds = Math.floor(millis / 1000);\n  const nanos = (millis - seconds * 1000) * 1e6;\n\n  if (seconds < 0 || seconds > 0x400000000) {\n    // Timestamp96\n    const encoded = Buffer.allocUnsafe(13);\n    encoded[0] = -1;\n    encoded.writeUInt32BE(nanos, 1);\n    let hex = '';\n\n    if (seconds >= 0) {\n      const padhex = '0000000000000000';\n      hex = seconds.toString(16); // add some padding\n\n      hex = padhex.slice(0, hex.length * -1) + hex;\n    } else {\n      // encode seconds in 2's Complement 64Bit\n      // reverse sign\n      // keep all bits 0 and first 1 from right\n      // reverse all other bits\n      let bin = (seconds * -1).toString(2);\n      let i = bin.length - 1;\n\n      while (bin[i] === '0') {\n        i--;\n      }\n\n      bin = bin.slice(0, i).split('').map(function (bit) {\n        return bit === '1' ? 0 : 1;\n      }).join('') + bin.slice(i, bin.length); // add some padding\n\n      const pad64 = '1111111111111111111111111111111111111111111111111111111111111111';\n      bin = pad64.slice(0, bin.length * -1) + bin; // convert to hex\n\n      bin.match(/.{1,8}/g).forEach(function (byte) {\n        byte = parseInt(byte, 2).toString(16);\n\n        if (byte.length === 1) {\n          byte = '0' + byte;\n        }\n\n        hex += byte;\n      });\n    }\n\n    encoded.write(hex, 5, 'hex');\n    return encoded;\n  } else if (nanos || seconds > 0xffffffff) {\n    // Timestamp64\n    const encoded = Buffer.allocUnsafe(9);\n    encoded[0] = -1;\n    const upperNanos = nanos * 4;\n    const upperSeconds = seconds / Math.pow(2, 32);\n    const upper = upperNanos + upperSeconds & 0xffffffff;\n    const lower = seconds & 0xffffffff;\n    encoded.writeInt32BE(upper, 1);\n    encoded.writeInt32BE(lower, 5);\n    return encoded;\n  } else {\n    // Timestamp32\n    const encoded = Buffer.allocUnsafe(5);\n    encoded[0] = -1;\n    encoded.writeUInt32BE(Math.floor(millis / 1000), 1);\n    return encoded;\n  }\n}\n\nfunction check(obj) {\n  return typeof obj.getDate === 'function';\n}\n\nfunction decode(buf) {\n  let seconds;\n  let nanoseconds = 0;\n  let upper;\n  let lower;\n  let hex;\n\n  switch (buf.length) {\n    case 4:\n      // timestamp 32 stores the number of seconds that have elapsed since 1970-01-01 00:00:00 UTC in an 32-bit unsigned integer\n      seconds = buf.readUInt32BE(0);\n      break;\n\n    case 8:\n      // Timestamp 64 stores the number of seconds and nanoseconds that have elapsed\n      // since 1970-01-01 00:00:00 UTC in 32-bit unsigned integers, split 30/34 bits\n      upper = buf.readUInt32BE(0);\n      lower = buf.readUInt32BE(4);\n      nanoseconds = upper / 4;\n      seconds = (upper & 0x03) * Math.pow(2, 32) + lower; // If we use bitwise operators, we get truncated to 32bits\n\n      break;\n\n    case 12:\n      // timestamp 96 stores the number of seconds and nanoseconds that have elapsed\n      // since 1970-01-01 00:00:00 UTC in 64-bit signed integer and 32-bit unsigned integer\n      // get seconds in hex\n      hex = buf.toString('hex', 4, 12); // check if seconds is a negative number\n\n      if (parseInt(buf.toString('hex', 4, 6), 16) & 0x80) {\n        // convert to binary\n        let bin = '';\n        const pad8 = '00000000';\n        hex.match(/.{1,2}/g).forEach(function (byte) {\n          byte = parseInt(byte, 16).toString(2);\n          byte = pad8.slice(0, byte.length * -1) + byte;\n          bin += byte;\n        }); // decode seconds from 2's Complement 64Bit\n        // reverse all bits\n        // reverse sign\n        // remove one\n\n        seconds = -1 * parseInt(bin.split('').map(function (bit) {\n          return bit === '1' ? 0 : 1;\n        }).join(''), 2) - 1;\n      } else {\n        seconds = parseInt(hex, 16);\n      }\n\n      nanoseconds = buf.readUInt32BE(0);\n  }\n\n  const millis = seconds * 1000 + Math.round(nanoseconds / 1E6);\n  return new Date(millis);\n}\n\nmodule.exports = {\n  check,\n  type,\n  encode,\n  decode\n};","map":{"version":3,"names":["type","encode","dt","millis","seconds","Math","floor","nanos","encoded","Buffer","allocUnsafe","writeUInt32BE","hex","padhex","toString","slice","length","bin","i","split","map","bit","join","pad64","match","forEach","byte","parseInt","write","upperNanos","upperSeconds","pow","upper","lower","writeInt32BE","check","obj","getDate","decode","buf","nanoseconds","readUInt32BE","pad8","round","Date","module","exports"],"sources":["/Users/matthewbrown/Desktop/code/Summer/Stock-Portfolio/stock-portfolio/node_modules/msgpack5/lib/codecs/DateCodec.js"],"sourcesContent":["const type = -1\n\nfunction encode (dt) {\n  if (dt === null) {\n    return\n  }\n\n  const millis = dt * 1\n  const seconds = Math.floor(millis / 1000)\n  const nanos = (millis - seconds * 1000) * 1e6\n\n  if (seconds < 0 || seconds > 0x400000000) {\n    // Timestamp96\n    const encoded = Buffer.allocUnsafe(13)\n    encoded[0] = -1\n\n    encoded.writeUInt32BE(nanos, 1)\n\n    let hex = ''\n    if (seconds >= 0) {\n      const padhex = '0000000000000000'\n      hex = seconds.toString(16)\n      // add some padding\n      hex = padhex.slice(0, hex.length * -1) + hex\n    } else {\n      // encode seconds in 2's Complement 64Bit\n      // reverse sign\n      // keep all bits 0 and first 1 from right\n      // reverse all other bits\n      let bin = (seconds * -1).toString(2)\n      let i = bin.length - 1\n      while (bin[i] === '0') {\n        i--\n      }\n      bin = bin.slice(0, i).split('').map(function (bit) { return bit === '1' ? 0 : 1 }).join('') + bin.slice(i, bin.length)\n      // add some padding\n      const pad64 = '1111111111111111111111111111111111111111111111111111111111111111'\n      bin = pad64.slice(0, bin.length * -1) + bin\n      // convert to hex\n      bin.match(/.{1,8}/g).forEach(function (byte) {\n        byte = parseInt(byte, 2).toString(16)\n        if (byte.length === 1) {\n          byte = '0' + byte\n        }\n        hex += byte\n      })\n    }\n    encoded.write(hex, 5, 'hex')\n    return encoded\n  } else if (nanos || seconds > 0xffffffff) {\n    // Timestamp64\n    const encoded = Buffer.allocUnsafe(9)\n    encoded[0] = -1\n\n    const upperNanos = nanos * 4\n    const upperSeconds = seconds / Math.pow(2, 32)\n    const upper = (upperNanos + upperSeconds) & 0xffffffff\n    const lower = seconds & 0xffffffff\n\n    encoded.writeInt32BE(upper, 1)\n    encoded.writeInt32BE(lower, 5)\n    return encoded\n  } else {\n    // Timestamp32\n    const encoded = Buffer.allocUnsafe(5)\n    encoded[0] = -1\n    encoded.writeUInt32BE(Math.floor(millis / 1000), 1)\n    return encoded\n  }\n}\n\nfunction check (obj) {\n  return typeof obj.getDate === 'function'\n}\n\nfunction decode (buf) {\n  let seconds\n  let nanoseconds = 0\n  let upper\n  let lower\n  let hex\n\n  switch (buf.length) {\n    case 4:\n      // timestamp 32 stores the number of seconds that have elapsed since 1970-01-01 00:00:00 UTC in an 32-bit unsigned integer\n      seconds = buf.readUInt32BE(0)\n      break\n\n    case 8:\n      // Timestamp 64 stores the number of seconds and nanoseconds that have elapsed\n      // since 1970-01-01 00:00:00 UTC in 32-bit unsigned integers, split 30/34 bits\n      upper = buf.readUInt32BE(0)\n      lower = buf.readUInt32BE(4)\n      nanoseconds = upper / 4\n      seconds = ((upper & 0x03) * Math.pow(2, 32)) + lower // If we use bitwise operators, we get truncated to 32bits\n      break\n\n    case 12:\n      // timestamp 96 stores the number of seconds and nanoseconds that have elapsed\n      // since 1970-01-01 00:00:00 UTC in 64-bit signed integer and 32-bit unsigned integer\n\n      // get seconds in hex\n      hex = buf.toString('hex', 4, 12)\n      // check if seconds is a negative number\n      if (parseInt(buf.toString('hex', 4, 6), 16) & 0x80) {\n        // convert to binary\n        let bin = ''\n        const pad8 = '00000000'\n        hex.match(/.{1,2}/g).forEach(function (byte) {\n          byte = parseInt(byte, 16).toString(2)\n          byte = pad8.slice(0, byte.length * -1) + byte\n          bin += byte\n        })\n        // decode seconds from 2's Complement 64Bit\n        // reverse all bits\n        // reverse sign\n        // remove one\n        seconds = -1 * parseInt(bin.split('').map(function (bit) { return bit === '1' ? 0 : 1 }).join(''), 2) - 1\n      } else {\n        seconds = parseInt(hex, 16)\n      }\n\n      nanoseconds = buf.readUInt32BE(0)\n  }\n\n  const millis = (seconds * 1000) + Math.round(nanoseconds / 1E6)\n\n  return new Date(millis)\n}\n\nmodule.exports = { check, type, encode, decode }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}